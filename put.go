package ddbfns

import (
	"fmt"
	"reflect"
	"strconv"
	"time"

	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

// PutOpts customises [Fns.Put] operations per each invocation.
type PutOpts struct {
	// DisableOptimisticLocking, if true, will skip all logic concerning version attribute.
	DisableOptimisticLocking bool
	// DisableAutoGeneratedTimestamps, if true, will skip all logic concerning timestamp attributes.
	DisableAutoGeneratedTimestamps bool

	// TableName modifies the [dynamodb.PutItemInput.TableName]
	TableName string
	// ReturnConsumedCapacity modifies the [dynamodb.PutItemInput.ReturnConsumedCapacity]
	ReturnConsumedCapacity types.ReturnConsumedCapacity
	// ReturnItemCollectionMetrics modifies the [dynamodb.PutItemInput.ReturnItemCollectionMetrics]
	ReturnItemCollectionMetrics types.ReturnItemCollectionMetrics
	// ReturnValues modifies the [dynamodb.PutItemInput.ReturnValues]
	ReturnValues types.ReturnValue
	// ReturnValuesOnConditionCheckFailure modifies the [dynamodb.PutItemInput.ReturnValuesOnConditionCheckFailure].
	ReturnValuesOnConditionCheckFailure types.ReturnValuesOnConditionCheckFailure
}

// Put creates the PutItem request for the given item.
//
// If the item's version is at its zero value, `attribute_not_exists(#hash_key)` is used as the condition expression
// to prevent overriding an existing item with the same key in database. The version attribute in the
// `map[string]AttributeValue` return value will be incremented by 1.
//
// If the item's version is not at its zero value, `#version = :version` is used as the condition expression to perform
// optimistic locking. The version attribute in the `map[string]AttributeValue` return value will be incremented by 1.
//
// Any zero-value created or modified timestamps will be set to [time.Now] unless disabled by PutOpts.
func (f *Fns) Put(v interface{}, optFns ...func(*PutOpts)) (*dynamodb.PutItemInput, error) {
	f.init.Do(f.initFn)

	opts := &PutOpts{}
	for _, fn := range optFns {
		fn(opts)
	}

	iv := reflect.ValueOf(v)
	attrs, err := f.loadOrParse(reflect.TypeOf(v))
	if err != nil {
		return nil, err
	}

	// PutItem requires the entire map[string]AttributeValue item.
	var item map[string]types.AttributeValue
	if av, err := f.Encoder.Encode(v); err != nil {
		return nil, err
	} else if asMap, ok := av.(*types.AttributeValueMemberM); !ok {
		return nil, fmt.Errorf("item did not encode to M type")
	} else {
		item = asMap.Value
	}

	condition := expression.ConditionBuilder{}

	if versionAttr := attrs.Version; !opts.DisableOptimisticLocking && versionAttr != nil {
		version, err := versionAttr.Get(iv)
		if err != nil {
			return nil, fmt.Errorf("get version value error: %w", err)
		}

		switch {
		case version.IsZero():
			condition = expression.Name(attrs.HashKey.Name).AttributeNotExists()
			item[versionAttr.Name] = &types.AttributeValueMemberN{Value: "1"}
		case version.CanInt():
			condition = expression.Name(versionAttr.Name).Equal(expression.Value(item[versionAttr.Name]))
			item[versionAttr.Name] = &types.AttributeValueMemberN{Value: strconv.FormatInt(version.Int()+1, 10)}
		case version.CanUint():
			condition = expression.Name(versionAttr.Name).Equal(expression.Value(item[versionAttr.Name]))
			item[versionAttr.Name] = &types.AttributeValueMemberN{Value: strconv.FormatUint(version.Uint()+1, 10)}
		case version.CanFloat():
			condition = expression.Name(versionAttr.Name).Equal(expression.Value(item[versionAttr.Name]))
			item[versionAttr.Name] = &types.AttributeValueMemberN{Value: strconv.FormatFloat(version.Float(), 'f', -1, 64)}
		default:
			panic(fmt.Errorf("version attribute's type (%s) is unknown numeric type", version.Type()))
		}
	}

	now := time.Now()

	if createdTimeAttr := attrs.CreatedTime; !opts.DisableAutoGeneratedTimestamps && createdTimeAttr != nil {
		createdTime, err := createdTimeAttr.Get(iv)
		if err != nil {
			return nil, fmt.Errorf("get createdTime value error: %w", err)
		}

		var av types.AttributeValue
		if createdTime.IsZero() {
			if createdTimeAttr.UnixTime {
				if av, err = attributevalue.UnixTime(now).MarshalDynamoDBAttributeValue(); err != nil {
					return nil, fmt.Errorf("encode createdTime as UnixTime error: %w", err)
				}
			} else {
				updateValue := reflect.ValueOf(now).Convert(createdTime.Type())
				if av, err = f.Encoder.Encode(updateValue.Interface()); err != nil {
					return nil, fmt.Errorf("encode createdTime error: %w", err)
				}
			}

			item[createdTimeAttr.Name] = av
		}
	}

	if modifiedTimeAttr := attrs.ModifiedTime; !opts.DisableAutoGeneratedTimestamps && modifiedTimeAttr != nil {
		modifiedTime, err := modifiedTimeAttr.Get(iv)
		if err != nil {
			return nil, fmt.Errorf("get modifiedTime value error: %w", err)
		}

		var av types.AttributeValue
		if modifiedTime.IsZero() {
			if modifiedTimeAttr.UnixTime {
				av, err = attributevalue.UnixTime(now).MarshalDynamoDBAttributeValue()
				if err != nil {
					return nil, fmt.Errorf("encode modifiedTime as UnixTime error: %w", err)
				}
			} else {
				updateValue := reflect.ValueOf(now).Convert(modifiedTime.Type())
				if av, err = f.Encoder.Encode(updateValue.Interface()); err != nil {
					return nil, fmt.Errorf("encode modifiedTime error: %w", err)
				}
			}

			item[modifiedTimeAttr.Name] = av
		}
	}

	if condition.IsSet() {
		expr, err := expression.NewBuilder().WithCondition(condition).Build()
		if err != nil {
			return nil, fmt.Errorf("build expressions error: %w", err)
		}

		return &dynamodb.PutItemInput{
			Item:                                item,
			TableName:                           &opts.TableName,
			ConditionExpression:                 expr.Condition(),
			ExpressionAttributeNames:            expr.Names(),
			ExpressionAttributeValues:           expr.Values(),
			ReturnConsumedCapacity:              opts.ReturnConsumedCapacity,
			ReturnItemCollectionMetrics:         opts.ReturnItemCollectionMetrics,
			ReturnValues:                        opts.ReturnValues,
			ReturnValuesOnConditionCheckFailure: opts.ReturnValuesOnConditionCheckFailure,
		}, nil
	}

	return &dynamodb.PutItemInput{
		Item:                                item,
		TableName:                           &opts.TableName,
		ReturnConsumedCapacity:              opts.ReturnConsumedCapacity,
		ReturnItemCollectionMetrics:         opts.ReturnItemCollectionMetrics,
		ReturnValues:                        opts.ReturnValues,
		ReturnValuesOnConditionCheckFailure: opts.ReturnValuesOnConditionCheckFailure,
	}, nil
}

// Put creates the PutItem request for the given item.
//
// Put is a wrapper around [DefaultFns.Put]; see [Fns.Put] for more information.
func Put(v interface{}, optFns ...func(*PutOpts)) (*dynamodb.PutItemInput, error) {
	return DefaultFns.Put(v, optFns...)
}
